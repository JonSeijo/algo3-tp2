% !TEX root = ./informe.tex

\section{Problema 2}

\subsection{Explicación}

El contexto del problema es el siguiente: tenemos un conjunto de ciudades conectadas por rutas con peajes. El costo de un peaje es cuanto se debe pagar por transitar la ruta, y el mismo puede ser negativo (uno en vez de pagar por pasar, cobra). Decimos que hay un `abuso' si podemos partir de una ciudad $c$ arbitraria y volver, teniendo un saldo positivo de dinero. El problema es encontrar el máximo $c$ que le puedo restar a todos los peajes sin que haya ningún abuso. \\

Notemos que podemos considerar a las ciudades como nodos, a las rutas como aristas, y a los peajes como el peso de las mismas; modelando el contexto como un grafo \todo{rotulado?}. Visto esto, el problema se reduce a encontrar el máximo $k$ tal que en el grafo en el que todos los pesos decrementan en $k$, no hay circuito simples negativos. \\

\subsection{Correctitud}

La noción de abuso en un grafo se corresponde con la existencia de ciclos negativos. Por esta razón, para resolver el problema querremos ser capaces de responder si un grafo tiene ciclos negativos o no. \\

El algoritmo de Bellman Ford es capaz de detectar si hay un ciclo negativo entre dos nodos. Sin embargo, notemos que la ausencia de ciclos negativos entre dos nodos no necesariamente implica que no exista uno en el grafo al que pertenecen. Esto puede ocurrir porque no se nos garantiza que la entrada forme un grafo orientado fuertemente conexo, por lo que podríamos llegar a tener un ciclo negativo cuyos nodos no sean alcanzables por el nodo en el cuál arrancamos. \\

Para solucionar esto, vamos a extender nuestro grafo de entrada con un nuevo nodo $u$ con una arista hacia todos los demás nodos. De esta forma, todos los nodos (y por ende los posibles ciclos negativos) son alcanzables desde $u$, con lo cual aplicando Bellman Ford podemos ver la existencia de ciclos negativos. Como solo estamos agregando aristas de ida desde un nuevo nodo, no agregamos nuevos ciclos, por lo que estaríamos obteniendo si nuestro grafo original presenta un abuso o no. \\

Esto nos da una forma de detectar abuso en grafos. Ahora, lo que pide el enunciado es encontrar el máximo valor por el cual puedo decrementar el peso de todos los ejes sin que haya abuso. Lo que vamos a hacer es una suerte de búsqueda binaria sobre el rango $[0..c+2)$. \\

Veamos primero que el $k$ que buscamos se encuentra en ese rango. No puede ser negativo, porque estamos buscando un máximo, y porque en la entrada no tenemos abuso, lo que implica que el $0$ ya es posible candidato a solución. Tampoco puede ser mayor a $c+1$ , porque como $c$ es el máximo costo, quedarían todos los costos de los peajes negativos. Por el enunciado, sabemos que todas las ciudades tienen una ruta de salida, con lo cual siempre podemos asegurar que existe al menos un ciclo. Si todos los peajes son negativos, esto implica que nos quedaría algún ciclo negativo. \\

¿Cómo hacemos la búsqueda binaria? En cada iteración tomamos el valor $m$ a la mitad de nuestro espacio de búsqueda, y preguntamos si nuestro grafo con los pesos decrementados en $m$ presenta abuso. Si hay, entonces sabemos que nuestro $k$ no es $m$; y que si ya con $m$ tenemos un abuso, con valores mayores lo seguiremos teniendo. Por ende, puedo descartar a $m$ y a la mitad superior de nuestro espacio de búsqueda. Si por el contrario, restando $m$ no nos da un abuso, entonces $m$ es un posible candidato a $k$. Como busco un máximo, puedo descartar la mitad inferior de nuestro espacio de búsqueda. Entonces, lo que estariamos buscando efectivamente sería el máximo $k$ tal que no hay abuso en el grafo producto de haber decrementado todos los pesos de los ejes en $k$. \\

\newpage
\subsection{Pseudocódigo}
\todo[inline]{Falta agregar comentarios sobre las complejidades}

Vamos a utilizar como entrada en nuestro algoritmo a las siguientes variables:
\begin{itemize}
	\item $n$: La cantidad de ciudades
	\item $grafo$: El grafo de entrada representado con listas de adyacencia. Las posiciones del $1$ a $n$ representan nuestras ciudades, mientras que la posición $0$ se deja libre para la extensión
	\item $costo$: La matriz con los costos de peaje, en donde en la posición $(i,j)$ está el costo de la ruta que va desde $i$ hasta $j$
	\item $c$: El máximo costo de peaje
\end{itemize}

\begin{algorithm}[H]
% \label{ej2}         % and a label for \ref{} commands later in the document
\begin{algorithmic}
\Function{Resolver}{}
	\State ExtenderGrafo()
    \State $d \gets 0$
	\State $h \gets c + 2$
	\While{$h - d > 1$}
		\State $mid \gets (h + d)/2$
		\If{$\neg$HayAbuso($mid$)}
			\State $d \gets mid$
		\Else
			\State $h \gets mid$ \\
		\EndIf
	\EndWhile
	\Return $d$
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}
\Function{ExtenderGrafo}{}
	\For{$i \in [1..n)$}
		\State AgregarAdelante($grafo[0], i$)
		\State $costo[0][i] \gets 0$
	\EndFor
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}
\Function{HayAbuso}{$resta: Int$}
	\State $dist \gets$ InitMatrizInfinito($n + 1$)
	\State $dist[0] \gets 0$
	\For{$i \in [1..n)$}
		\For{$nodo \in [0..n]$}
			\For{$vecino \in grafo[nodo]$}
				\State $peso \gets grafo[nodo][vecino] - resta$
				\State $dist[vecino] \gets$ Min($dist[vecino], dist[nodo] + peso$) \\
			\EndFor
		\EndFor
	\EndFor
	\Return HayCicloNegativo($dist, resta$)
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\begin{algorithmic}
\Function{HayCicloNegativo}{$dist: Int[], resta: Int$}
	\For{$nodo \in [0..n]$}
		\For{$vecino \in grafo[nodo]$}
			\State $peso \gets grafo[nodo][vecino] - resta$
			\If{$dist[vecino] > dist[nodo] + peso$}
				\State \Return True \\
			\EndIf
		\EndFor
	\EndFor
	\Return False
\EndFunction
\end{algorithmic}
\end{algorithm}

\newpage

\subsection{Complejidad}

\subsection{Experimentos}